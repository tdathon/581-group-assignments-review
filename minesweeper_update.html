<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Minesweeper</title>

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Tangerine">

  <style>
  /* CSS by Jay Patel (09/10)*/

  /* Global */
  * { box-sizing: border-box; }

  /* Body */
  body {
    font-family: 'Tangerine', sans-serif;
    font-size: 35px;
    background-color: #00FFFF;
    color: #1e293b;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    padding: 1rem;
    margin: 0;
    touch-action: manipulation;
  }

  /* Heading */
  h1 {
    text-align: center;
    font-size: 2.25rem;
    font-weight: 700;
    margin-top: 0;
    margin-bottom: 1rem;
  }

  /* Number input and start button */
  .controls {
    display: grid;
    grid-template-columns: 1fr;
    gap: 1rem;
    margin-bottom: 1rem;
    padding: 1rem;
    background-color: #f8fafc;
    border-radius: 0.5rem;
    border: 1px solid #e2e8f0;
  }

  /* Container for the game */
  .container {
    width: 100%;
    max-width: 512px;
    margin: 0 auto;
    background-color: white;
    border-radius: 0.75rem;
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    padding: 1.5rem;
  }

  @media (min-width: 768px) {
    .controls { grid-template-columns: 1fr 1fr; align-items: flex-end; }
  }

  /* For mines user input */
  .input-group { display: flex; flex-direction: column; }
  .input-group label {
    font-size: 0.875rem;
    font-weight: 500;
    color: #475569;
    margin-bottom: 0.25rem;
  }

  .input-group input, .input-group select {
    padding: 0.5rem;
    border: 1px solid #cbd5e1;
    border-radius: 0.375rem;
    box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    font-size: 1rem;
    background: white;
  }

  .input-group input:focus, .input-group select:focus {
    outline: 2px solid transparent;
    outline-offset: 2px;
    border-color: #3b82f6;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
  }

  /* For the start button */
  #start-button {
    width: 100%;
    padding: 0.6rem 1rem;
    background-color: #2563eb;
    color: white;
    font-weight: 600;
    border-radius: 0.5rem;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    border: none;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.2s;
  }
  #start-button:hover {
    background-color: #1d4ed8;
    transform: scale(1.02);
  }

  /* For the bar below start that shows victory or playing or loss */
  .status-display {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: #f1f5f9;
    padding: 0.75rem;
    border-radius: 0.5rem;
    margin-bottom: 1rem;
    color: #334155;
  }
  .status-display span { font-weight: 600; }
  .status-playing { color: #2563eb; }
  .status-win { color: #16a34a; }
  .status-loss { color: #dc2626; }

  /* For the actual game */
  #grid-container {
    background-color: #1af065;
    padding: 0.5rem;
    border-radius: 0.5rem;
    box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
    display: grid;
    gap: 2px;
  }

  /* For the axes of the game */
  .grid-label {
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    color: #1e293b;
  }

  /* For each cell in the grid, subcategory is self-explanatory */
  .cell {
    width: 100%;
    padding-bottom: 100%;
    position: relative;
    background-color: #cbd5e1;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.15s ease-in-out;
    user-select: none;
  }
  .cell:not(.revealed):hover { background-color: #94a3b8; }

  .cell.revealed { background-color: #f1f5f9; cursor: default; }
  .cell.flagged { background-image: linear-gradient(to top right, #cbd5e1, #e2e8f0); }

  .cell.mine { background-color: #f87171; }

  /* For the image or text inside the cell */
  .cell-content {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.25rem;
    font-weight: bold;
  }
  .c1 { color: #3b82f6; } 
  .c2 { color: #00ffd0; } 
  .c3 { color: #fe0000; }
  .c4 { color: #6366f1; } 
  .c5 { color: #a855f7; } 
  .c6 { color: #0891b2; }
  .c7 { color: #1e293b; } 
  .c8 { color: #03fc0f; }
  </style>
</head>
<!-- Brett Balquist: HTML skeleton (09/09)-->
<body>

  <div class="container">
    <h1>Minesweeper</h1>

    <div class="controls">
      <div class="input-group">
        <label for="mine-input">Number of Mines (10â€“20):</label>
        <!-- Alec Slavik: fix to the mine numbers (originally 5-25 now correct 10-20 (9/24) -->
        <input type="number" id="mine-input" value="10" min="10" max="20" />
        <!-- Alec Slavik, removing user typing in box, only ticker allowed to stay in range) (9/24) -->
        <script>
          const mineInput = document.getElementById('mine-input');
          // Stops typing, only stepper allowed
          mineInput.addEventListener('keydown', (e) => { e.preventDefault(); });
        </script>
      </div>

      <!-- AI mode dropdown -->
      <div class="input-group">
        <label for="ai-mode">Opponent:</label>
        <select id="ai-mode">
          <option value="none">No AI</option>
          <option value="easy">Easy AI</option>
          <option value="medium">Medium AI</option>
          <option value="hard">Hard AI</option>
        </select>
      </div>

      <button id="start-button">Start Game</button>
    </div>

    <div class="status-display">
      <div>Status: <span id="status-indicator">Ready</span></div>
      <div>Flags Left: <span id="flags-left">N/A</span></div>
    </div>

    <!-- Board -->
    <div id="grid-container"></div>
  </div>

  <script>
    // --- CONSTANTS ---
    const GRID_SIZE = 10;

    // --- DOM Elements (aligned to CSS) ---
    const gridContainer = document.getElementById('grid-container');
    const mineInputElement = document.getElementById('mine-input');
    const startButton = document.getElementById('start-button');
    const statusIndicatorElement = document.getElementById('status-indicator');
    const flagCountElement = document.getElementById('flags-left');
    const aiModeElement = document.getElementById('ai-mode');

    // --- SOUND EFFECTS ---
    // Files expected in ./sounds:
    // - clicksound.mp3, flagsound.mp3, winsound.mp3, losesound.mp3
    const sfx = {
      click: new Audio('sounds/clicksound.mp3'),
      flag:  new Audio('sounds/flagsound.mp3'),
      win:   new Audio('sounds/winsound.mp3'),
      lose:  new Audio('sounds/losesound.mp3')
    };

    // Preload (no crossOrigin set, so it works with file://)
    Object.values(sfx).forEach(a => { a.preload = 'auto'; });

    // Play helper: clone so rapid repeats can overlap
    function playSFX(name) {
      const base = sfx[name];
      if (!base) return;
      try {
        const node = base.cloneNode(true);
        node.currentTime = 0;
        node.play().catch(() => {});
      } catch (_) {}
    }

    // Optional: prime audio on first user gesture to satisfy autoplay rules
    let sfxPrimed = false;
    function primeSFX() {
      if (sfxPrimed) return;
      sfxPrimed = true;
      const silent = sfx.click.cloneNode(true);
      silent.volume = 0;
      silent.play().catch(() => {});
      setTimeout(() => { try { silent.pause(); } catch(_){} }, 50);
    }
    // Prime on the very first click or key press anywhere
    window.addEventListener('click', primeSFX, { once: true, capture: true });
    window.addEventListener('keydown', primeSFX, { once: true, capture: true });


    // --- GAME STATE OBJECT ---
    let gameState = {
      board: [],
      mineCount: 10,
      flagsPlaced: 0,
      revealedCells: 0,
      status: 'ready', // 'ready', 'playing', 'win', 'loss'
      firstClick: true,
      // AI + turn state
      aiMode: 'none',        // 'none' | 'easy' | 'medium' | 'hard'
      nextToMove: 'user',    // 'user' | 'ai'
      aiBusy: false          // block clicks while AI is moving
    };

    // --- BOARD MANAGER ---

    /** Initializes the board */
    function initializeBoard() {
      gameState.board = Array.from({ length: GRID_SIZE }, () =>
        Array.from({ length: GRID_SIZE }, () => ({
          isMine: false,
          isRevealed: false,
          isFlagged: false,
          adjacentMines: 0
        }))
      );
    }

    /** Places the mines (after the click) */
    function placeMines(startRow, startCol) {
      let minesToPlace = gameState.mineCount;
      while (minesToPlace > 0) {
        const r = Math.floor(Math.random() * GRID_SIZE);
        const c = Math.floor(Math.random() * GRID_SIZE);
        if ((r === startRow && c === startCol) || gameState.board[r][c].isMine) continue;
        gameState.board[r][c].isMine = true;
        minesToPlace--;
      }
    }

    /** For each tile, calculates adjacent mine counts */
    function calculateAdjacentMines() {
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          if (gameState.board[r][c].isMine) continue;
          let count = 0;
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              const nr = r + dr;
              const nc = c + dc;
              if (isValid(nr, nc) && gameState.board[nr][nc].isMine) count++;
            }
          }
          gameState.board[r][c].adjacentMines = count;
        }
      }
    }

    // --- GAME LOGIC ---

    /** Starts the game */
    function startGame() {
      const requested = parseInt(mineInputElement.value, 10);
      gameState.mineCount = Math.max(10, Math.min(20, isNaN(requested) ? 10 : requested));

      gameState.flagsPlaced = 0;
      gameState.revealedCells = 0;
      gameState.status = 'playing';
      gameState.firstClick = true;

      // reset AI/turns
      gameState.aiMode = aiModeElement ? aiModeElement.value : 'none';
      gameState.nextToMove = 'user';
      gameState.aiBusy = false;

      initializeBoard();
      renderBoard();
      updateUI();
    }

    /** Reveal a cell (fromAI toggles "who clicked") */
    function revealCell(row, col, fromAI = false) {
      if (!isValid(row, col)) return;
      const cell = gameState.board[row][col];
      if (cell.isRevealed || cell.isFlagged) return;

      if (cell.isMine) {
        // If AI hits a mine, player wins; if user hits, player loses
        endGame(fromAI ? true : false);
        return;
      }

      cell.isRevealed = true;
      gameState.revealedCells++;

      if (cell.adjacentMines === 0) {
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            revealCell(row + dr, col + dc, fromAI);
          }
        }
      }
      checkWinCondition();
    }

    /** Toggle flag on a cell */
    function toggleFlag(row, col) {
      const cell = gameState.board[row][col];
      if (cell.isRevealed) return;
      if (cell.isFlagged) {
        cell.isFlagged = false;
        gameState.flagsPlaced--;
      } else if (gameState.flagsPlaced < gameState.mineCount) {
        cell.isFlagged = true;
        gameState.flagsPlaced++;
      }
    }

    /** Win check */
    function checkWinCondition() {
      const nonMineCells = (GRID_SIZE * GRID_SIZE) - gameState.mineCount;
      if (gameState.revealedCells === nonMineCells) {
        endGame(true);
      }
    }

    /** End the game */
    function endGame(isWin) {
      gameState.status = isWin ? 'win' : 'loss';
      gameState.board.forEach(row => row.forEach(cell => {
        if (cell.isMine) cell.isRevealed = true;
      }));
      // --- SFX: win/lose (added, no logic change) ---
      playSFX(isWin ? 'win' : 'lose');
      updateUI();
    }

    /** Valid cell? */
    function isValid(row, col) {
      return (row >= 0) && (col >= 0) && (row < GRID_SIZE) && (col < GRID_SIZE);
    }

    // --- Helpers for AI ---
    function getNeighbors(r, c) {
      const out = [];
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          const nr = r + dr, nc = c + dc;
          if (isValid(nr, nc)) out.push({ r: nr, c: nc });
        }
      }
      return out;
    }

    function isCovered(r, c) {
      const cell = gameState.board[r][c];
      return !cell.isRevealed;
    }
    function isFlagged(r, c) {
      return gameState.board[r][c].isFlagged;
    }
    function getNumberAt(r, c) {
      const cell = gameState.board[r][c];
      if (cell.isRevealed && !cell.isMine) return cell.adjacentMines;
      return null;
    }

    // --- USER INTERFACE ---

    /** Render the full board */
    function renderBoard() {
      gridContainer.innerHTML = '';
      gridContainer.style.gridTemplateColumns = `30px repeat(${GRID_SIZE}, 1fr)`;
      gridContainer.style.gridTemplateRows = `30px repeat(${GRID_SIZE}, 1fr)`;

      // top-left blank header
      gridContainer.appendChild(document.createElement('div'));

      // top A..J
      for (let i = 0; i < GRID_SIZE; i++) {
        const label = document.createElement('div');
        label.className = 'grid-label';
        label.textContent = String.fromCharCode(65 + i);
        gridContainer.appendChild(label);
      }

      // rows + cells
      for (let r = 0; r < GRID_SIZE; r++) {
        const label = document.createElement('div');
        label.className = 'grid-label';
        label.textContent = r + 1;
        gridContainer.appendChild(label);

        for (let c = 0; c < GRID_SIZE; c++) {
          const cellElement = document.createElement('div');
          cellElement.className = 'cell';
          cellElement.dataset.row = r;
          cellElement.dataset.col = c;
          cellElement.innerHTML = `<div class="cell-content"></div>`;
          gridContainer.appendChild(cellElement);
        }
      }
    }

    /** Update cell visuals */
    function updateBoardUI() {
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const cell = gameState.board[r][c];
          const cellElement = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
          const cellContent = cellElement.firstChild;

          cellElement.className = 'cell';
          cellContent.textContent = '';
          cellContent.className = 'cell-content';

          if (cell.isFlagged) {
            cellElement.classList.add('flagged');
            cellContent.textContent = 'ðŸš©';
          } else if (cell.isRevealed) {
            cellElement.classList.add('revealed');
            if (cell.isMine) {
              cellElement.classList.add('mine');
              cellContent.textContent = 'ðŸ’£';
            } else if (cell.adjacentMines > 0) {
              cellContent.textContent = cell.adjacentMines;
              cellContent.classList.add(`c${cell.adjacentMines}`);
            }
          }
        }
      }
    }

    /** Shake the screen on loss */
    function shakeScreenWhenLose() {
      const body = document.body;
      const start = Date.now();
      let x = 5;
      const interval = setInterval(() => {
        const ms = Date.now() - start;
        if (ms >= 500) {
          clearInterval(interval);
          body.style.transform = "";
          return;
        }
        body.style.transform = `translateX(${x}px)`;
        x = -x * 0.9;
      }, 30);
    }

    /** Update status and flag count */
    function updateUI() {
      flagCountElement.textContent = Math.max(0, gameState.mineCount - gameState.flagsPlaced);
      const span = statusIndicatorElement;
      span.className = '';
      switch (gameState.status) {
        case 'playing':
          span.textContent = (gameState.aiMode === 'none')
            ? 'Playing'
            : (gameState.nextToMove === 'user' ? 'Your turn' : 'AI thinkingâ€¦');
          span.classList.add('status-playing');
          break;
        case 'win':
          span.textContent = 'Victory! ðŸŽ‰';
          span.classList.add('status-win');
          break;
        case 'loss':
          shakeScreenWhenLose();
          span.textContent = 'Game Over: Loss';
          span.classList.add('status-loss');
          break;
        default:
          span.textContent = 'Ready';
      }
      updateBoardUI();
    }

    // --- INPUT HANDLER ---

    /** Left click */
    function handleCellClick(event) {
      const cellElement = event.target.closest('.cell');
      if (!cellElement || gameState.status !== 'playing') return;

      // only allow user action when it's user's turn and AI not busy
      if (gameState.aiMode !== 'none' && (gameState.aiBusy || gameState.nextToMove !== 'user')) return;

      // --- SFX: user clicked a tile (added, no logic change) ---
      playSFX('click');

      const row = parseInt(cellElement.dataset.row, 10);
      const col = parseInt(cellElement.dataset.col, 10);

      if (gameState.firstClick) {
        gameState.firstClick = false;
        placeMines(row, col);
        calculateAdjacentMines();
      }
      revealCell(row, col, /*fromAI*/ false);
      updateUI();

      // pass the turn to AI
      if (gameState.status === 'playing' && gameState.aiMode !== 'none') {
        gameState.nextToMove = 'ai';
        maybeRunAI();
      }
    }

    /** Right click (flag) */
    function handleCellRightClick(event) {
      event.preventDefault();
      const cellElement = event.target.closest('.cell');
      if (!cellElement || gameState.status !== 'playing') return;

      // block flags during AI move
      if (gameState.aiMode !== 'none' && (gameState.aiBusy || gameState.nextToMove !== 'user')) return;

      const row = parseInt(cellElement.dataset.row, 10);
      const col = parseInt(cellElement.dataset.col, 10);

      // capture state before toggling to know if a flag was actually placed
      const wasFlagged = gameState.board[row][col].isFlagged;

      toggleFlag(row, col);

      // --- SFX: flag placed (added, no logic change) ---
      if (!wasFlagged && gameState.board[row][col].isFlagged) {
        playSFX('flag');
      }

      updateUI();
    }

    // --- AI TURN LOOP ---
    function maybeRunAI() {
      if (gameState.status !== 'playing' || gameState.aiMode === 'none' || gameState.nextToMove !== 'ai') return;
      gameState.aiBusy = true;
      updateUI();

      // tiny delay for UX
      setTimeout(() => {
        if (gameState.aiMode === 'easy') aiEasyMove();
        else if (gameState.aiMode === 'medium') aiMediumMove();
        else if (gameState.aiMode === 'hard') aiHardMove();

        // after AI finishes (unless game ended), give turn back to user
        if (gameState.status === 'playing') {
          gameState.nextToMove = 'user';
        }
        gameState.aiBusy = false;
        updateUI();
      }, 120);
    }

    // --- EASY AI ---
    function aiEasyMove() {
      if (gameState.firstClick) return;
      const covered = [];
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          if (isCovered(r, c) && !isFlagged(r, c)) covered.push({ r, c });
        }
      }
      if (covered.length === 0) return;
      const pick = covered[(Math.random() * covered.length) | 0];
      revealCell(pick.r, pick.c, true);
    }

    // --- MEDIUM AI ---
    // Rule 1: If number of hidden neighbors equals cell's number (minus flags), flag all hidden neighbors
    // Rule 2: If number of flagged neighbors equals cell's number, open all other hidden neighbors
    // Else: Pick a random hidden cell
    function aiMediumMove() {
      if (gameState.firstClick) return;

      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const n = getNumberAt(r, c);
          if (n === null || n === 0) continue;
          const neigh = getNeighbors(r, c);
          let flagCount = 0;
          const hidden = [];
          for (const { r: nr, c: nc } of neigh) {
            if (isFlagged(nr, nc)) {
              flagCount++;
            } else if (isCovered(nr, nc)) {
              hidden.push({ r: nr, c: nc });
            }
          }
          const remainingMines = n - flagCount;
          if (remainingMines > 0 && hidden.length === remainingMines) {
            for (const { r: nr, c: nc } of hidden) {
              if (gameState.flagsPlaced < gameState.mineCount) {
                toggleFlag(nr, nc);
                playSFX('flag');
              }
            }
            return; 
          }
        }
      }
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const n = getNumberAt(r, c);
          if (n === null || n === 0) continue;
          const neigh = getNeighbors(r, c);
          let flagCount = 0;
          const hidden = [];
          for (const { r: nr, c: nc } of neigh) {
            if (isFlagged(nr, nc)) {
              flagCount++;
            } else if (isCovered(nr, nc)) {
              hidden.push({ r: nr, c: nc });
            }
          }
          if (flagCount === n && hidden.length > 0) {
            for (const { r: nr, c: nc } of hidden) {
              if (gameState.status !== 'playing') break;
              revealCell(nr, nc, /*fromAI*/ true);
            }
            return;
          }
        }
      }
      const allHidden = [];
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          if (isCovered(r, c) && !isFlagged(r, c)) {
            allHidden.push({ r, c });
          }
        }
      }
      if (allHidden.length > 0) {
        const pick = allHidden[Math.floor(Math.random() * allHidden.length)];
        revealCell(pick.r, pick.c, /*fromAI*/ true);
      }
    }

    // --- HARD AI (cheats): always uncover a safe cell (never detonates) ---
    function aiHardMove() {
      // If the first move hasn't happened yet, pick any start cell,
      // place mines protecting that cell, compute numbers, then reveal it.
      if (gameState.firstClick) {
        const startRow = Math.floor(GRID_SIZE / 2);
        const startCol = Math.floor(GRID_SIZE / 2);
        gameState.firstClick = false;
        placeMines(startRow, startCol);     // guarantees (startRow,startCol) isn't a mine
        calculateAdjacentMines();
        revealCell(startRow, startCol, /*fromAI*/ true);
        return;
      }

      // After first click: pick any hidden, unflagged, NON-MINE cell (cheating by peeking at isMine)
      const safeChoices = [];
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const cell = gameState.board[r][c];
          if (!cell.isRevealed && !cell.isFlagged && !cell.isMine) {
            safeChoices.push({ r, c });
          }
        }
      }
      if (safeChoices.length === 0) return; // nothing safe left (should imply win soon)

      // choose one (random for variety)
      const pick = safeChoices[(Math.random() * safeChoices.length) | 0];
      revealCell(pick.r, pick.c, /*fromAI*/ true);
    }

    // --- INITIALIZATION ---
    startButton.addEventListener('click', startGame);
    gridContainer.addEventListener('click', handleCellClick);
    gridContainer.addEventListener('contextmenu', handleCellRightClick);

    if (aiModeElement) {
      aiModeElement.addEventListener('change', () => {
        gameState.aiMode = aiModeElement.value;
      });
    }

    startGame();
  </script>
</body>
</html>
