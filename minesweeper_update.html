<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Minesweeper</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Tangerine">
  <style>
  * { box-sizing: border-box; }
  body {
    font-family: 'Tangerine', sans-serif;
    font-size: 35px;
    background-color: #00FFFF;
    color: #1e293b;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    padding: 1rem;
    margin: 0;
    touch-action: manipulation;
  }
  h1 { text-align: center; font-size: 2.25rem; font-weight: 700; margin-top: 0; margin-bottom: 1rem; }
  .controls {
    display: grid;
    grid-template-columns: 1fr;
    gap: 1rem;
    margin-bottom: 1rem;
    padding: 1rem;
    background-color: #f8fafc;
    border-radius: 0.5rem;
    border: 1px solid #e2e8f0;
  }
  .container {
    width: 100%;
    max-width: 512px;
    margin: 0 auto;
    background-color: white;
    border-radius: 0.75rem;
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    padding: 1.5rem;
  }
  @media (min-width: 768px) {
    .controls { grid-template-columns: 1fr 1fr; align-items: flex-end; }
  }
  .input-group { display: flex; flex-direction: column; }
  .input-group label {
    font-size: 0.875rem;
    font-weight: 500;
    color: #475569;
    margin-bottom: 0.25rem;
  }
  .input-group input, .input-group select {
    padding: 0.5rem;
    border: 1px solid #cbd5e1;
    border-radius: 0.375rem;
    box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    font-size: 1rem;
    background: white;
  }
  .input-group input:focus, .input-group select:focus {
    outline: 2px solid transparent;
    outline-offset: 2px;
    border-color: #3b82f6;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
  }
  .watch-mode-container {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem;
    background-color: #fef3c7;
    border-radius: 0.375rem;
    border: 1px solid #fbbf24;
  }
  .watch-mode-container label {
    margin: 0;
    font-size: 0.875rem;
    font-weight: 600;
    color: #92400e;
    cursor: pointer;
    user-select: none;
  }
  .watch-mode-container input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
  #start-button {
    width: 100%;
    padding: 0.6rem 1rem;
    background-color: #2563eb;
    color: white;
    font-weight: 600;
    border-radius: 0.5rem;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    border: none;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.2s;
  }
  #start-button:hover { background-color: #1d4ed8; transform: scale(1.02); }
  .status-display {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: #f1f5f9;
    padding: 0.75rem;
    border-radius: 0.5rem;
    margin-bottom: 1rem;
    color: #334155;
  }
  .status-display span { font-weight: 600; }
  .status-playing { color: #2563eb; }
  .status-win { color: #16a34a; }
  .status-loss { color: #dc2626; }
  #grid-container {
    background-color: #1af065;
    padding: 0.5rem;
    border-radius: 0.5rem;
    box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
    display: grid;
    gap: 2px;
  }
  .grid-label {
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    color: #1e293b;
  }
  .cell {
    width: 100%;
    padding-bottom: 100%;
    position: relative;
    background-color: #cbd5e1;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.15s ease-in-out;
    user-select: none;
  }
  .cell:not(.revealed):hover { background-color: #94a3b8; }
  .cell.revealed { background-color: #f1f5f9; cursor: default; }
  .cell.flagged { background-image: linear-gradient(to top right, #cbd5e1, #e2e8f0); }
  .cell.mine { background-color: #f87171; }
  .cell-content {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.25rem;
    font-weight: bold;
  }
  .c1 { color: #3b82f6; }
  .c2 { color: #00ffd0; }
  .c3 { color: #fe0000; }
  .c4 { color: #6366f1; }
  .c5 { color: #a855f7; }
  .c6 { color: #0891b2; }
  .c7 { color: #1e293b; }
  .c8 { color: #03fc0f; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Minesweeper</h1>
    <div class="controls">
      <div class="input-group">
        <label for="mine-input">Number of Mines (10‚Äì20):</label>
        <input type="number" id="mine-input" value="10" min="10" max="20" />
      </div>
      <div class="input-group">
        <label for="ai-mode">Opponent:</label>
        <select id="ai-mode">
          <option value="none">No AI</option>
          <option value="easy">Easy AI</option>
          <option value="medium">Medium AI</option>
          <option value="hard">Hard AI</option>
        </select>
      </div>
      <div class="watch-mode-container">
        <input type="checkbox" id="watch-mode" />
        <label for="watch-mode">üëÅÔ∏è Watch AI Play (AI only)</label>
      </div>
      <button id="start-button">Start Game</button>
    </div>
    <div class="status-display">
      <div>Status: <span id="status-indicator">Ready</span></div>
      <div>Flags Left: <span id="flags-left">N/A</span></div>
    </div>
    <div id="grid-container"></div>
  </div>
  <script>
    // constant grid size and DOM references
    const GRID_SIZE = 10;
    const gridContainer = document.getElementById('grid-container');
    const mineInputElement = document.getElementById('mine-input');
    const startButton = document.getElementById('start-button');
    const statusIndicatorElement = document.getElementById('status-indicator');
    const flagCountElement = document.getElementById('flags-left');
    const aiModeElement = document.getElementById('ai-mode');
    const watchModeCheckbox = document.getElementById('watch-mode');
   
    // prevent manual typing so value stays within min/max via arrows/taps
    mineInputElement.addEventListener('keydown', (e) => { e.preventDefault(); });

    // sound effects for clicks, flags, win, and loss
    const sfx = {
      click: new Audio('sounds/clicksound.mp3'),
      flag:  new Audio('sounds/flagsound.mp3'),
      win:   new Audio('sounds/winsound.mp3'),
      lose:  new Audio('sounds/losesound.mp3')
    };
    Object.values(sfx).forEach(a => { a.preload = 'auto'; });

    // safe sound playback helper
    function playSFX(name) {
      const base = sfx[name];
      if (!base) return;
      try {
        const node = base.cloneNode(true);
        node.currentTime = 0;
        node.play().catch(() => {});
      } catch (_) {}
    }

    // first user gesture primes audio to avoid autoplay blocks
    let sfxPrimed = false;
    function primeSFX() {
      if (sfxPrimed) return;
      sfxPrimed = true;
      const silent = sfx.click.cloneNode(true);
      silent.volume = 0;
      silent.play().catch(() => {});
      setTimeout(() => { try { silent.pause(); } catch(_){} }, 50);
    }
    window.addEventListener('click', primeSFX, { once: true, capture: true });
    window.addEventListener('keydown', primeSFX, { once: true, capture: true });

    // all game state lives here so it‚Äôs easy to reset and render
    let gameState = {
      board: [],
      mineCount: 10,
      flagsPlaced: 0,
      revealedCells: 0,
      status: 'ready',
      firstClick: true,
      aiMode: 'none',
      nextToMove: 'user',
      aiBusy: false,
      watchMode: false
    };

    // make an empty GRID_SIZE x GRID_SIZE board
    function initializeBoard() {
      gameState.board = Array.from({ length: GRID_SIZE }, () =>
        Array.from({ length: GRID_SIZE }, () => ({
          isMine: false,
          isRevealed: false,
          isFlagged: false,
          adjacentMines: 0
        }))
      );
    }

    // randomly place mines, never on the very first clicked cell
    function placeMines(startRow, startCol) {
      let minesToPlace = gameState.mineCount;
      while (minesToPlace > 0) {
        const r = Math.floor(Math.random() * GRID_SIZE);
        const c = Math.floor(Math.random() * GRID_SIZE);
        if ((r === startRow && c === startCol) || gameState.board[r][c].isMine) continue;
        gameState.board[r][c].isMine = true;
        minesToPlace--;
      }
    }

    // count and store each non-mine cell‚Äôs neighboring mine total
    function calculateAdjacentMines() {
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          if (gameState.board[r][c].isMine) continue;
          let count = 0;
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              const nr = r + dr;
              const nc = c + dc;
              if (isValid(nr, nc) && gameState.board[nr][nc].isMine) count++;
            }
          }
          gameState.board[r][c].adjacentMines = count;
        }
      }
    }

    // start or restart a game: read inputs, reset state, render
    function startGame() {
      const requested = parseInt(mineInputElement.value, 10);
      gameState.mineCount = Math.max(10, Math.min(20, isNaN(requested) ? 10 : requested));
      gameState.flagsPlaced = 0;
      gameState.revealedCells = 0;
      gameState.status = 'playing';
      gameState.firstClick = true;
      gameState.aiMode = aiModeElement ? aiModeElement.value : 'none';
      gameState.watchMode = watchModeCheckbox.checked;
      gameState.nextToMove = gameState.watchMode ? 'ai' : 'user';
      gameState.aiBusy = false;
      initializeBoard();
      renderBoard();
      updateUI();
      if (gameState.watchMode && gameState.aiMode !== 'none') {
        maybeRunAI();
      }
    }

    // reveal logic with flood-fill for zeros; handles mine hit and win checks
    function revealCell(row, col, fromAI = false) {
      if (!isValid(row, col)) return;
      const cell = gameState.board[row][col];
      if (cell.isRevealed || cell.isFlagged) return;

      // mine = end game; when not in watch mode, we treat AI mines as its loss
      if (cell.isMine) {
        if (gameState.watchMode) {
          endGame(false);
        } else {
          endGame(fromAI ? true : false);
        }
        return;
      }

      cell.isRevealed = true;
      gameState.revealedCells++;

      // auto-reveal neighbors if this tile has zero adjacent mines
      if (cell.adjacentMines === 0) {
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            revealCell(row + dr, col + dc, fromAI);
          }
        }
      }
      checkWinCondition();
    }

    // right-click flag toggler with cap equal to total mines
    function toggleFlag(row, col) {
      const cell = gameState.board[row][col];
      if (cell.isRevealed) return;
      if (cell.isFlagged) {
        cell.isFlagged = false;
        gameState.flagsPlaced--;
      } else if (gameState.flagsPlaced < gameState.mineCount) {
        cell.isFlagged = true;
        gameState.flagsPlaced++;
      }
    }

    // if all safe cells are revealed, game won
    function checkWinCondition() {
      const nonMineCells = (GRID_SIZE * GRID_SIZE) - gameState.mineCount;
      if (gameState.revealedCells === nonMineCells) {
        endGame(true);
      }
    }

    // finalize state, expose all mines, play sfx, refresh UI
    function endGame(isWin) {
      gameState.status = isWin ? 'win' : 'loss';
      gameState.board.forEach(row => row.forEach(cell => {
        if (cell.isMine) cell.isRevealed = true;
      }));
      // --- SFX: win/lose (added, no logic change) ---
      playSFX(isWin ? 'win' : 'lose');
      updateUI();
    }

    // helpers for board math and reading cell state
    function isValid(row, col) {
      return (row >= 0) && (col >= 0) && (row < GRID_SIZE) && (col < GRID_SIZE);
    }

    function getNeighbors(r, c) {
      const out = [];
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          const nr = r + dr, nc = c + dc;
          if (isValid(nr, nc)) out.push({ r: nr, c: nc });
        }
      }
      return out;
    }

    function isCovered(r, c) {
      const cell = gameState.board[r][c];
      return !cell.isRevealed;
    }
    function isFlagged(r, c) {
      return gameState.board[r][c].isFlagged;
    }
    function getNumberAt(r, c) {
      const cell = gameState.board[r][c];
      if (cell.isRevealed && !cell.isMine) return cell.adjacentMines;
      return null;
    }

    // build the header labels and all cell elements
    function renderBoard() {
      gridContainer.innerHTML = '';
      gridContainer.style.gridTemplateColumns = `30px repeat(${GRID_SIZE}, 1fr)`;
      gridContainer.style.gridTemplateRows = `30px repeat(${GRID_SIZE}, 1fr)`;
      gridContainer.appendChild(document.createElement('div')); // corner

      // top A‚ÄìJ labels
      for (let i = 0; i < GRID_SIZE; i++) {
        const label = document.createElement('div');
        label.className = 'grid-label';
        label.textContent = String.fromCharCode(65 + i);
        gridContainer.appendChild(label);
      }

      // each row label + its cells
      for (let r = 0; r < GRID_SIZE; r++) {
        const label = document.createElement('div');
        label.className = 'grid-label';
        label.textContent = r + 1;
        gridContainer.appendChild(label);
        for (let c = 0; c < GRID_SIZE; c++) {
          const cellElement = document.createElement('div');
          cellElement.className = 'cell';
          cellElement.dataset.row = r;
          cellElement.dataset.col = c;
          cellElement.innerHTML = `<div class="cell-content"></div>`;
          gridContainer.appendChild(cellElement);
        }
      }
    }

    // reflect the latest board state visually
    function updateBoardUI() {
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const cell = gameState.board[r][c];
          const cellElement = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
          const cellContent = cellElement.firstChild;
          cellElement.className = 'cell';
          cellContent.textContent = '';
          cellContent.className = 'cell-content';
          if (cell.isFlagged) {
            cellElement.classList.add('flagged');
            cellContent.textContent = 'üö©';
          } else if (cell.isRevealed) {
            cellElement.classList.add('revealed');
            if (cell.isMine) {
              cellElement.classList.add('mine');
              cellContent.textContent = 'üí£';
            } else if (cell.adjacentMines > 0) {
              cellContent.textContent = cell.adjacentMines;
              cellContent.classList.add(`c${cell.adjacentMines}`);
            }
          }
        }
      }
    }

    // small screen shake for a loss moment
    function shakeScreenWhenLose() {
      const body = document.body;
      const start = Date.now();
      let x = 5;
      const interval = setInterval(() => {
        const ms = Date.now() - start;
        if (ms >= 500) {
          clearInterval(interval);
          body.style.transform = "";
          return;
        }
        body.style.transform = `translateX(${x}px)`;
        x = -x * 0.9;
      }, 30);
    }

    // update status text/color and redraw the board
    function updateUI() {
      flagCountElement.textContent = Math.max(0, gameState.mineCount - gameState.flagsPlaced);
      const span = statusIndicatorElement;
      span.className = '';
      switch (gameState.status) {
        case 'playing':
          if (gameState.watchMode) {
            span.textContent = 'AI Playing...';
          } else {
            span.textContent = (gameState.aiMode === 'none')
              ? 'Playing'
              : (gameState.nextToMove === 'user' ? 'Your turn' : 'AI thinking‚Ä¶');
          }
          span.classList.add('status-playing');
          break;
        case 'win':
          span.textContent = gameState.watchMode ? 'AI Won! üéâ' : 'Victory! üéâ';
          span.classList.add('status-win');
          break;
        case 'loss':
          shakeScreenWhenLose();
          span.textContent = gameState.watchMode ? 'AI Lost' : 'Game Over: Loss';
          span.classList.add('status-loss');
          break;
        default:
          span.textContent = 'Ready';
      }
      updateBoardUI();
    }

    // left-click reveal, handles first-click safety and AI turn handoff
    function handleCellClick(event) {
      const cellElement = event.target.closest('.cell');
      if (!cellElement || gameState.status !== 'playing') return;
      if (gameState.watchMode) return;
      if (gameState.aiMode !== 'none' && (gameState.aiBusy || gameState.nextToMove !== 'user')) return;

      // --- SFX: user clicked a tile (added, no logic change) ---
      playSFX('click');

      const row = parseInt(cellElement.dataset.row, 10);
      const col = parseInt(cellElement.dataset.col, 10);
      if (gameState.firstClick) {
        gameState.firstClick = false;
        placeMines(row, col);
        calculateAdjacentMines();
      }
      revealCell(row, col, false);
      updateUI();
      if (gameState.status === 'playing' && gameState.aiMode !== 'none') {
        gameState.nextToMove = 'ai';
        maybeRunAI();
      }
    }

    // right-click flagging, with flag sound on new flags
    function handleCellRightClick(event) {
      event.preventDefault();
      const cellElement = event.target.closest('.cell');
      if (!cellElement || gameState.status !== 'playing') return;
      if (gameState.watchMode) return;
      if (gameState.aiMode !== 'none' && (gameState.aiBusy || gameState.nextToMove !== 'user')) return;
      const row = parseInt(cellElement.dataset.row, 10);
      const col = parseInt(cellElement.dataset.col, 10);

      // capture state before toggling to know if a flag was actually placed
      const wasFlagged = gameState.board[row][col].isFlagged;

      toggleFlag(row, col);

      // --- SFX: flag placed (added, no logic change) ---
      if (!wasFlagged && gameState.board[row][col].isFlagged) {
        playSFX('flag');
      }

      updateUI();
    }

    // runs the selected AI once, and loops if watch mode is on
    function maybeRunAI() {
      if (gameState.status !== 'playing' || gameState.aiMode === 'none' || gameState.nextToMove !== 'ai') return;
      gameState.aiBusy = true;
      updateUI();
      setTimeout(() => {
        if (gameState.aiMode === 'easy') aiEasyMove();
        else if (gameState.aiMode === 'medium') aiMediumMove();
        else if (gameState.aiMode === 'hard') aiHardMove();
        if (gameState.status === 'playing') {
          if (gameState.watchMode) {
            gameState.nextToMove = 'ai';
          } else {
            gameState.nextToMove = 'user';
          }
        }
        gameState.aiBusy = false;
        updateUI();
        if (gameState.watchMode && gameState.status === 'playing') {
          maybeRunAI();
        }
      }, 300);
    }

    // easy AI: random first move and random subsequent safe-ish picks
    function aiEasyMove() {
      if (gameState.firstClick) {
        const startRow = Math.floor(Math.random() * GRID_SIZE);
        const startCol = Math.floor(Math.random() * GRID_SIZE);
        gameState.firstClick = false;
        placeMines(startRow, startCol);
        calculateAdjacentMines();
        revealCell(startRow, startCol, true);
        return;
      }
      const covered = [];
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          if (isCovered(r, c) && !isFlagged(r, c)) covered.push({ r, c });
        }
      }
      if (covered.length === 0) return;
      const pick = covered[(Math.random() * covered.length) | 0];
      revealCell(pick.r, pick.c, true);
    }

    // --- MEDIUM AI ---
  // Rule 1: If number - flags == hidden, flag all hidden
  // Rule 2: If flags == number, reveal all remaining hidden
  // Else: pick a random hidden, unflagged cell
  function aiMediumMove() {
    // Make a deliberate first move so the board initializes
    if (gameState.firstClick) {
      const startRow = Math.floor(GRID_SIZE / 2);
      const startCol = Math.floor(GRID_SIZE / 2);
      gameState.firstClick = false;
      placeMines(startRow, startCol);
      calculateAdjacentMines();
      revealCell(startRow, startCol, /*fromAI*/ true);
      return;
    }

    // PASS 1: Flag when certain
    for (let r = 0; r < GRID_SIZE; r++) {
      for (let c = 0; c < GRID_SIZE; c++) {
        const n = getNumberAt(r, c);
        if (n === null || n === 0) continue;

        const neigh = getNeighbors(r, c);
        let flagCount = 0;
        const hidden = [];

        for (const { r: nr, c: nc } of neigh) {
          if (isFlagged(nr, nc)) flagCount++;
          else if (isCovered(nr, nc)) hidden.push({ r: nr, c: nc });
        }

        const remainingMines = n - flagCount;
        if (remainingMines > 0 && hidden.length === remainingMines) {
          for (const { r: nr, c: nc } of hidden) {
            if (gameState.flagsPlaced < gameState.mineCount) {
              toggleFlag(nr, nc);
              playSFX('flag');
            }
          }
          return;
        }
      }
    }

    // PASS 2: Reveal safe neighbors when all mines are flagged
    for (let r = 0; r < GRID_SIZE; r++) {
      for (let c = 0; c < GRID_SIZE; c++) {
        const n = getNumberAt(r, c);
        if (n === null || n === 0) continue;

        const neigh = getNeighbors(r, c);
        let flagCount = 0;
        const hidden = [];

        for (const { r: nr, c: nc } of neigh) {
          if (isFlagged(nr, nc)) flagCount++;
          else if (isCovered(nr, nc)) hidden.push({ r: nr, c: nc });
        }

        if (flagCount === n && hidden.length > 0) {
          for (const { r: nr, c: nc } of hidden) {
            if (gameState.status !== 'playing') break;
            revealCell(nr, nc, /*fromAI*/ true);
          }
          return;
        }
      }
    }

    // FALLBACK: Random hidden, unflagged cell
    const allHidden = [];
    for (let r = 0; r < GRID_SIZE; r++) {
      for (let c = 0; c < GRID_SIZE; c++) {
        if (isCovered(r, c) && !isFlagged(r, c)) allHidden.push({ r, c });
      }
    }
    if (allHidden.length > 0) {
      const pick = allHidden[Math.floor(Math.random() * allHidden.length)];
      revealCell(pick.r, pick.c, /*fromAI*/ true);
    }
  }

    // hard AI: placeholder approach that avoids flagged/revealed and assumes safe pool
    function aiHardMove() {
      if (gameState.firstClick) {
        const startRow = Math.floor(GRID_SIZE / 2);
        const startCol = Math.floor(GRID_SIZE / 2);
        gameState.firstClick = false;
        placeMines(startRow, startCol);
        calculateAdjacentMines();
        revealCell(startRow, startCol, true);
        return;
      }
      const safeChoices = [];
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const cell = gameState.board[r][c];
          if (!cell.isRevealed && !cell.isFlagged && !cell.isMine) {
            safeChoices.push({ r, c });
          }
        }
      }
      if (safeChoices.length === 0) return;
      const pick = safeChoices[(Math.random() * safeChoices.length) | 0];
      revealCell(pick.r, pick.c, true);
    }

    // hook up UI interactions
    startButton.addEventListener('click', startGame);
    gridContainer.addEventListener('click', handleCellClick);
    gridContainer.addEventListener('contextmenu', handleCellRightClick);
    if (aiModeElement) {
      aiModeElement.addEventListener('change', () => {
        gameState.aiMode = aiModeElement.value;
      });
    }

    // auto-start a fresh game on load
    startGame();
  </script>
</body>
</html>
