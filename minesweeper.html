<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Minesweeper</title>

<link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Tangerine">

<style>
/* CSS by Jay Patel (09/10)*/

/* Global */
    * { box-sizing: border-box; }
/* Body */
    body {
        font-family: 'Tangerine', sans-serif;
        font-size: 35px;
        background-color: #00FFFF;
        color: #1e293b;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        padding: 1rem;
        margin: 0;
        touch-action: manipulation;    }


/* Heading */
    h1 {
        text-align: center;
        font-size: 2.25rem;
        font-weight: 700;
        margin-top: 0;
        margin-bottom: 1rem;
    }
/* Number input and start button */
    .controls {
        display: grid;
        grid-template-columns: 1fr;
        gap: 1rem;
        margin-bottom: 1rem;
        padding: 1rem;
        background-color: #f8fafc;
        border-radius: 0.5rem;
        border: 1px solid #e2e8f0;
    }
/* Container for the game */
    .container {
        width: 100%;
        max-width: 512px;
        margin: 0 auto;
        background-color: white;
        border-radius: 0.75rem;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        padding: 1.5rem;
    }
    @media (min-width: 768px) {
        .controls { grid-template-columns: 1fr 1fr; align-items: flex-end; }
    }
/* For mines user input */
    .input-group { display: flex; flex-direction: column; }
    .input-group label {
        font-size: 0.875rem;
        font-weight: 500;
        color: #475569;

        margin-bottom: 0.25rem;    }

    .input-group input {
        padding: 0.5rem;
        border: 1px solid #cbd5e1;
        border-radius: 0.375rem;
        box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); 
        font-size: 1rem;
    }


    .input-group input:focus {
        outline: 2px solid transparent;
        outline-offset: 2px;

        border-color: #3b82f6;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
    }
/* For the start button */
    #start-button {
        width: 100%;
        padding: 0.6rem 1rem;
        background-color: #2563eb;
        color: white;
        font-weight: 600;
        border-radius: 0.5rem;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        border: none;
        cursor: pointer;
        transition: background-color 0.2s, transform 0.2s;
    }
    #start-button:hover {
        background-color: #1d4ed8;
        transform: scale(1.02);
    }
/* For the bar below start that shows victory or playing or loss */
    .status-display {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: #f1f5f9;
        padding: 0.75rem;
        border-radius: 0.5rem;
        margin-bottom: 1rem;
        color: #334155;    }
    .status-display span { font-weight: 600; }
    .status-playing { color: #2563eb; }
    .status-win { color: #16a34a; }
    .status-loss { color: #dc2626; }
/* For the actual game */
    #grid-container {
        background-color: #1af065;
        padding: 0.5rem;
        border-radius: 0.5rem;
        box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
        display: grid;
        gap: 2px;
    }
/* For the axes of the game */
    .grid-label {
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        color: #1e293b;
    }
    
/* For each cell in the grid, subcategory is self-explanitory */
    .cell {
        width: 100%;
        padding-bottom: 100%;
        position: relative;
        background-color: #cbd5e1;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.15s ease-in-out;
        user-select: none;    }
    .cell:not(.revealed):hover { background-color: #94a3b8; }
    
    .cell.revealed { 
        background-color: #f1f5f9; cursor: default; }
    .cell.flagged { background-image: linear-gradient(to top right, #cbd5e1, #e2e8f0); }
    
    .cell.mine {
         background-color: #f87171; 
        }
    
    
/* For the image or text inside the cell */
    .cell-content {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.25rem;
        font-weight: bold;
    }
    .c1 { color: #3b82f6; } 
    .c2 { color: #00ffd0; } 
    .c3 { color: #fe0000; }
    .c4 { color: #6366f1; } 
    .c5 { color: #a855f7; } 
    .c6 { color: #0891b2; }
    .c7 { color: #1e293b; } 
    .c8 { color: #03fc0f; }

</style>
</head>
<!-- Brett Balquist: HTML skeleton (09/09)-->
<body>

  <div class="container">
    <h1>Minesweeper</h1>

    <div class="controls">
      <div class="input-group">
        <label for="mine-input">Number of Mines (5â€“25):</label>
        <input type="number" id="mine-input" value="10" min="5" max="25" />
      </div>
      <button id="start-button">Start Game</button>
    </div>

    <div class="status-display">
      <div>Status: <span id="status-indicator">Ready</span></div>
      <div>Flags Left: <span id="flags-left">N/A</span></div>
    </div>

    <!-- Board -->
    <div id="grid-container"></div>
  </div>

  <script>
    // --- CONSTANTS ---
    const GRID_SIZE = 10;
    // --- DOM Elements (aligned to CSS) ---
    const gridContainer = document.getElementById('grid-container');
    const mineInputElement = document.getElementById('mine-input');
    const startButton = document.getElementById('start-button');
    const statusIndicatorElement = document.getElementById('status-indicator');
    const flagCountElement = document.getElementById('flags-left');
    // --- GAME STATE OBJECT ---
    let gameState = {
      board: [],
      mineCount: 10,
      flagsPlaced: 0,
      revealedCells: 0,
      status: 'ready', // 'ready', 'playing', 'win', 'loss'
      firstClick: true
    };

    // --- BOARD MANAGER ---

    /**
    Daniel Neugent: Initializes the board
    Inputs: None
    Output:No return value but UI change (board on the screen of the correct size)
    Date: 09/10
    **/
    function initializeBoard() {
      gameState.board = Array.from({ length: GRID_SIZE }, () =>
        Array.from({ length: GRID_SIZE }, () => ({
          isMine: false,
          isRevealed: false,
          isFlagged: false,
          adjacentMines: 0
        }))
      );
    }

    /**
    Daniel Neugent: Places the mines (after the click)
    Inputs: start row and column, 
    Output: No return val but gamestate is changed
    Date: 09/10
    **/
    function placeMines(startRow, startCol) {
      let minesToPlace = gameState.mineCount;
      while (minesToPlace > 0) {
        const r = Math.floor(Math.random() * GRID_SIZE);
        const c = Math.floor(Math.random() * GRID_SIZE);
        if ((r === startRow && c === startCol) || gameState.board[r][c].isMine) continue;
        gameState.board[r][c].isMine = true;
        minesToPlace--;
      }
    }

    /**
    Tej Gumaste: For each tile it calculates how many mines are next to it
    Inputs: None
    Output: No return val but gamestate is changed
    Date: 09/10
    **/
    function calculateAdjacentMines() {

      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          if (gameState.board[r][c].isMine) continue;
          let count = 0;
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              const nr = r + dr;
              const nc = c + dc;
              if (isValid(nr, nc) && gameState.board[nr][nc].isMine) {
                count++;
              }
            }
          }
          gameState.board[r][c].adjacentMines = count;
        }
      }
    }

    // --- GAME LOGIC ---


    /**
    Daniel Neugent and Tej Gumaste: Starts the game
    Inputs: None
    Outputs: No return but starts the game
    Date: 09/10
    **/
    function startGame() {
      // clamp input to 5..25 just in case
      const requested = parseInt(mineInputElement.value, 10);
      gameState.mineCount = Math.max(5, Math.min(25, isNaN(requested) ? 10 : requested));

      gameState.flagsPlaced = 0;
      gameState.revealedCells = 0;
      gameState.status = 'playing';
      gameState.firstClick = true;

      initializeBoard();
      renderBoard();
      updateUI();
    }


    /**
    Daniel Neugent and Tej Gumaste: Shows contents of the cell upon click and 
    updates the game state accordingly
    Inputs: Row and column of cell clicked
    Outputs: No return but game state and UI are changed
    Date: 09/10
    **/
    function revealCell(row, col) {
      if (!isValid(row, col)) return;
      const cell = gameState.board[row][col];
      if (cell.isRevealed || cell.isFlagged) return;

      if (cell.isMine) {
        endGame(false);
        return;
      }

      cell.isRevealed = true;
      gameState.revealedCells++;

      if (cell.adjacentMines === 0) {
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            revealCell(row + dr, col + dc);
          }
        }
      }
      checkWinCondition();
    }

    /**
    Tej Gumaste: Changes the input cell to have a flag
    updates the game state accordingly
    Inputs: row and column of cell clicked
    Outputs: No return but game state and UI are changed
    Date: 09/10
    **/
    function toggleFlag(row, col) {
      const cell = gameState.board[row][col];
      if (cell.isRevealed) return;
      if (cell.isFlagged) {
        cell.isFlagged = false;
        gameState.flagsPlaced--;
      } else if (gameState.flagsPlaced < gameState.mineCount) {
        cell.isFlagged = true;
        gameState.flagsPlaced++;
      }
    }

    /**
    Tej Gumaste: Checks to see if the game is won
    Inputs: None
    Outputs: None
    Date: 09/10
    **/
    function checkWinCondition() {
      const nonMineCells = (GRID_SIZE * GRID_SIZE) - gameState.mineCount;
      if (gameState.revealedCells === nonMineCells) {
        endGame(true);
      }
    }

    /**
    Daniel Neugent: Ends the game accordingly
    Inputs: Boolean var about whether the game was won or loss
    Outputs: None
    Date: 09/10
    **/
    function endGame(isWin) {
      gameState.status = isWin ? 'win' : 'loss';
      gameState.board.forEach(row => row.forEach(cell => {
        if (cell.isMine) cell.isRevealed = true;
      }));
      updateUI();
    }




    /**
    Arnav Jain: Checks if a move is valid
    Inputs: Row and col
    Outputs: Boolean
    Date: 09/10 initially, was accidentially overwritten so readded 9/21
    **/
    function isValid(row, col) {
        return (row >= 0) && (col >= 0) && (row < GRID_SIZE) && (col < GRID_SIZE);
    }
    // --- USER INTERFACE ---

    /**
    Daniel Neugent: Renders the full board
    Inputs: None
    Outputs: None but changes UI
    Date: 09/10
    **/
    function renderBoard() {
      gridContainer.innerHTML = '';
      gridContainer.style.gridTemplateColumns = `30px repeat(${GRID_SIZE}, 1fr)`;
      gridContainer.style.gridTemplateRows = `30px repeat(${GRID_SIZE}, 1fr)`;

      // top-left blank header
      gridContainer.appendChild(document.createElement('div'));

      // top A..J
      for (let i = 0; i < GRID_SIZE; i++) {
        const label = document.createElement('div');
        label.className = 'grid-label';
        label.textContent = String.fromCharCode(65 + i);
        gridContainer.appendChild(label);
      }

      // rows + cells
      for (let r = 0; r < GRID_SIZE; r++) {
        const label = document.createElement('div');
        label.className = 'grid-label';
        label.textContent = r + 1;
        gridContainer.appendChild(label);

        for (let c = 0; c < GRID_SIZE; c++) {
          const cellElement = document.createElement('div');
          cellElement.className = 'cell';
          cellElement.dataset.row = r;
          cellElement.dataset.col = c;
          cellElement.innerHTML = `<div class="cell-content"></div>`;
          gridContainer.appendChild(cellElement);
        }
      }
    }

    /**
    Daniel Neugent and Tej Gumaste: Helps render the cells in the board
    Inputs: None
    Outputs: None but changes UI
    Date: 09/10
    **/
    function updateBoardUI() {
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const cell = gameState.board[r][c];
          const cellElement = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
          const cellContent = cellElement.firstChild;

          cellElement.className = 'cell';
          cellContent.textContent = '';
          cellContent.className = 'cell-content';

          if (cell.isFlagged) {
            cellElement.classList.add('flagged');
            cellContent.textContent = 'ðŸš©';
          } else if (cell.isRevealed) {
            cellElement.classList.add('revealed');
            if (cell.isMine) {
              cellElement.classList.add('mine');
              cellContent.textContent = 'ðŸ’£';
            } else if (cell.adjacentMines > 0) {
              cellContent.textContent = cell.adjacentMines;
              cellContent.classList.add(`c${cell.adjacentMines}`);
            }
          }
        }
      }
    }

    /**
    Arnav Jain: SHakes the screen upon loss
    Inputs: None
    Outputs: None 
    Date: 09/10
    **/
    function shakeScreenWhenLose() {
        const body = document.body;
        const start = Date.now();

        // x is how much we want to shake at the start
        let x = 5;

        const interval = setInterval(() => {
            const ms = Date.now() - start;

            if (ms >= 500) {
                clearInterval(interval);
                body.style.transform = "";
                return;
            }

            body.style.transform = `translateX(${x}px)`;

            // flip x and multiply by .9 so that it lessens out
            x = -x * 0.9
        }, 30);
    }

    /**
    Daniel Neugent and Tej Gumaste: Updates the status text and flag count
    Inputs: None
    Outputs: None but changes UI
    Date: 09/10
    **/
    function updateUI() {
      flagCountElement.textContent = Math.max(0, gameState.mineCount - gameState.flagsPlaced);
      const span = statusIndicatorElement;
      span.className = '';
      switch (gameState.status) {
        case 'playing':
          span.textContent = 'Playing';
          span.classList.add('status-playing');
          break;
        case 'win':
          span.textContent = 'Victory! ðŸŽ‰';
          span.classList.add('status-win');
          break;
        case 'loss':
          shakeScreenWhenLose();
          span.textContent = 'Game Over: Loss';
          span.classList.add('status-loss');
          break;
        default:
          span.textContent = 'Ready';
      }
      updateBoardUI();
    }

    // --- INPUT HANDLER ---

    /**
    Tej Gumaste: Handls cell left click
    Inputs: event
    Outputs: None but changes UI and game state
    Date: 09/10
    **/
    function handleCellClick(event) {
      const cellElement = event.target.closest('.cell');
      if (!cellElement || gameState.status !== 'playing') return;
      const row = parseInt(cellElement.dataset.row, 10);
      const col = parseInt(cellElement.dataset.col, 10);

      if (gameState.firstClick) {
        gameState.firstClick = false;
        placeMines(row, col);
        calculateAdjacentMines();
      }
      revealCell(row, col);
      updateUI();
    }

    /**
    Daniel Neugent: Handls cell right click
    Inputs: event
    Outputs: None but changes UI and game state
    Date: 09/10
    **/
    function handleCellRightClick(event) {
      event.preventDefault();
      const cellElement = event.target.closest('.cell');
      if (!cellElement || gameState.status !== 'playing') return;
      const row = parseInt(cellElement.dataset.row, 10);
      const col = parseInt(cellElement.dataset.col, 10);
      toggleFlag(row, col);
      updateUI();
    }

    // --- INITIALIZATION ---
    startButton.addEventListener('click', startGame);
    gridContainer.addEventListener('click', handleCellClick);
    gridContainer.addEventListener('contextmenu', handleCellRightClick);

    startGame();
  </script>
</body>
</html>
